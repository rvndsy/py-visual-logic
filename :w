from logic_gates import GateInputCount, GateType
from typing import Dict
from PyQt6.QtCore import Qt, QSize, QLineF, QRectF
from PyQt6.QtGui import ( 
    QAction,
    QPixmap,
    QPainter,
    QPen,
    QColor,
    QBrush,
    QPainterPath,
)
from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QLabel,
    QWidget,
    QToolBar,

)
from PyQt6.QtWidgets import (
    QGraphicsScene,
    QGraphicsView,
    QGraphicsRectItem,
    QGraphicsItem,
    QGraphicsPixmapItem,
    QGraphicsLineItem,
    QGraphicsEllipseItem,
)

PIXMAP_FILES_DICT = {
    GateType.INPUT: "./symbols/IN.png",
    GateType.OUTPUT: "./symbols/OUT.png",
    GateType.AND: "./symbols/AND_ANSI.png",
    GateType.OR:  "./symbols/OR_ANSI.png",
    GateType.NOT: "./symbols/NOT_ANSI.png",
}

class Window(QMainWindow):
    AND_PIXMAP: QPixmap
    OR_PIXMAP: QPixmap
    NOT_PIXMAP: QPixmap
    PIXMAP_DICT: Dict[GateType, QPixmap] = {}

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("PyQt App")

        self.scene = Scene(0, 0, 400, 400)


        self.scene.addItem(DraggableNode(GateType.NOT, 100, 100))
        self.scene.addItem(DraggableNode(GateType.OR, 200, 300))
        self.scene.addItem(DraggableNode(GateType.AND, 100, 200))
        self.scene.addItem(DraggableNode(GateType.INPUT, 150, 50))
        self.scene.addItem(DraggableNode(GateType.OUTPUT, 50, 150))

        toolbar = QToolBar(parent=self)
        toolbar.setIconSize(QSize(16, 16))
        self.addToolBar(toolbar)
        openFileBtn = QAction("Open file", self)
        openFileBtn.setStatusTip("Open file")
        openFileBtn.triggered.connect(self.toolbarOpenFileBtnClicked)
        toolbar.addAction(openFileBtn)


        #drag1 = DraggableNode("Drag this", self)
        #drag1.setPixmap(AND_PIXMAP)
        #drag1.setGeometry(200, 100, AND_PIXMAP.size().width(), AND_PIXMAP.size().height())

        #self.updateScene()

        view = QGraphicsView(self.scene)
        view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setCentralWidget(view)
        return

    def toolbarOpenFileBtnClicked(self, s) -> None:
        print("click ", s)

    #def updateScene(self):
    #    for item in self.scene.items():
    #        item.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
    #        item.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)

    #def createGate(self, gate_type: GateType, x: int, y: int):
    #    pixmapItem = QGraphicsPixmapItem(self.PIXMAP_DICT[gate_type])
    #    pixmapItem.setPos(x, y)
    #    pixmapItem.setShapeMode(QGraphicsPixmapItem.ShapeMode.BoundingRectShape) # so that can drag on transparent pixels
    #    self.scene.addItem(pixmapItem)
    #    return

# https://stackoverflow.com/questions/65831884/how-to-connect-two-qgraphicsitem-by-drawing-line-between-them-using-mouse
class ConnectionLine(QGraphicsLineItem):
    LINE_WIDTH = 4
    LINE_COLOR = QColor("black")
    lineBrush = QBrush(QColor("red"))
    def __init__(self, start, p2):
        super().__init__()
        self.start = start
        self.end = None
        self._line = QLineF(start.scenePos(), p2)
        self.setLine(self._line)
        self.setPenParams(self.LINE_COLOR, self.LINE_WIDTH)

    def connectionPoints(self):
        return self.start, self.end

    def setPenParams(self, color: QColor, width: int) -> None:
        pen = QPen(color)
        pen.setWidth(width)
        self.setPen(pen)
        return

    def setP2(self, p2):
        self._line.setP2(p2)
        self.setLine(self._line)

    def setStart(self, start):
        self.start = start
        self.updateLine(start)

    def setEnd(self, end):
        self.end = end
        self.updateLine(end)

    def updateLine(self, source):
        if source == self.start:
            self._line.setP1(source.scenePos())
        else:
            self._line.setP2(source.scenePos())
        self.setLine(self._line)

class ConnectionPoint(QGraphicsEllipseItem):
    DIAMETER = 6
    isInput: bool
    lines: list
    pointBrush = QBrush(QColor("black"))
    def __init__(self, parent, isInput):
        super().__init__(-self.DIAMETER/2, -self.DIAMETER/2, self.DIAMETER, self.DIAMETER, parent)
        self.isInput = isInput
        self.lines = []
        # this flag **must** be set after creating self.lines!
        self.setFlags(self.GraphicsItemFlag.ItemSendsScenePositionChanges)
        self.setBrush(self.pointBrush)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, enabled=False)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsFocusable, enabled=False)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, enabled=False)

    def addLine(self, lineItem: ConnectionLine):
        for existing in self.lines:
            if existing.connectionPoints() == lineItem.connectionPoints():
                # another line with the same connection points already exists
                return False
            if lineItem.connectionPoints() == :
        self.lines.append(lineItem)
        return True

    def removeLine(self, lineItem):
        for existing in self.lines:
            if existing.connectionPoints() == lineItem.connectionPoints():
                scene = self.scene()
                if scene is not None:
                    scene.removeItem(existing)
                    self.lines.remove(existing)
                    return True
        return False

    def itemChange(self, change, value):
        for line in self.lines:
            line.updateLine(self)
        return super().itemChange(change, value)

class DraggableNode(QGraphicsItem):
    gateType: GateType
    pixmap: QPixmap
    inputCount: int

    def __init__(self, gateType: GateType, x: int , y: int, *args, **kwargs):
        super().__init__(*args, **kwargs)
        #self.pen = QPen(Qt.GlobalColor.black, 2)
        #self.connectionBrush = QBrush(QColor(214, 13, 36))
        self.rect = QRectF(0, 0, 100, 100)
        self.setFlags(self.GraphicsItemFlag.ItemIsMovable)
        self.setPos(x, y)

        self.gateType = gateType

        self.connections = []
        self.pixmap = QPixmap(PIXMAP_FILES_DICT[gateType])

        self.inputCount = GateInputCount[gateType]
        if self.inputCount == 1:
            connectionPoint = ConnectionPoint(self, False)
            self.connections.append(connectionPoint)
            connectionPoint.setX(0 + ConnectionPoint.DIAMETER)
            connectionPoint.setY(self.getCenterY())
        if self.inputCount == 2:
            connectionPoint = ConnectionPoint(self, False)
            self.connections.append(connectionPoint)
            connectionPoint.setX(0 + ConnectionPoint.DIAMETER)
            connectionPoint.setY(self.getCenterY() + 9.5)
            connectionPoint = ConnectionPoint(self, False)
            self.connections.append(connectionPoint)
            connectionPoint.setX(0 + ConnectionPoint.DIAMETER)
            connectionPoint.setY(self.getCenterY() - 9.5)

        # Assuming just 1 output for now...
        connectionPoint = ConnectionPoint(self, True)
        connectionPoint.setX(float(self.pixmap.width()) - ConnectionPoint.DIAMETER/2)
        connectionPoint.setY(self.getCenterY())
        self.connections.append(connectionPoint)

    def getCenterY(self) -> float:
        return float(self.pixmap.height())/2

    def paint(self, painter: QPainter | None, option, widget = None):
        if painter is not None:
            painter.drawPixmap(0, 0, self.pixmap)


    def boundingRect(self):
        return self.rect

class Scene(QGraphicsScene):
    startItem = newConnection = None
    def connectionPointAt(self, pos):
        mask = QPainterPath()
        mask.setFillRule(Qt.FillRule.WindingFill)
        for item in self.items(pos):
            if mask.contains(pos):
                # ignore objects hidden by others
                return
            if isinstance(item, ConnectionPoint):
                return item
            if not isinstance(item, ConnectionLine):
                mask.addPath(item.shape().translated(item.scenePos()))

    def mousePressEvent(self, event):
        if event is not None and event.button() == Qt.MouseButton.LeftButton:
            item = self.connectionPointAt(event.scenePos())
            if item:
                self.startItem = item
                self.newConnection = ConnectionLine(item, event.scenePos())
                self.addItem(self.newConnection)
                return
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if event is not None and self.newConnection:
            item = self.connectionPointAt(event.scenePos())
            if (item and item != self.startItem and self.startItem is not None and self.startItem.isInput != item.isInput):
                    p2 = item.scenePos()
            else:
                p2 = event.scenePos()
            self.newConnection.setP2(p2)
            return
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if event is not None and self.newConnection:
            item = self.connectionPointAt(event.scenePos())
            if self.startItem is not None and item and item != self.startItem:
                self.newConnection.setEnd(item)
                if self.startItem.addLine(self.newConnection):
                    item.addLine(self.newConnection)
                else:
                    # delete the connection if it exists; remove the following
                    # line if this feature is not required
                    self.startItem.removeLine(self.newConnection)
                    self.removeItem(self.newConnection)
            else:
                self.removeItem(self.newConnection)
        self.startItem = self.newConnection = None
        super().mouseReleaseEvent(event)
